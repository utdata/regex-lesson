<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Christian McDonald">
<meta name="dcterms.date" content="2025-06-14">

<title>Wrangling data with Regular Expressions – Regex for NICAR</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-6bbb2ee3340c67b6da55fdc5589aeeb3.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Regex for NICAR</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Wrangling Regular Expressions</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./cheatsheet.html"> 
<span class="menu-text">Cheatsheet</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#dont-fear-the-regex" id="toc-dont-fear-the-regex" class="nav-link active" data-scroll-target="#dont-fear-the-regex">Don’t fear the regex</a></li>
  <li><a href="#special-characters-commands-and-escape" id="toc-special-characters-commands-and-escape" class="nav-link" data-scroll-target="#special-characters-commands-and-escape">Special characters, commands and escape</a></li>
  <li><a href="#regex101.com" id="toc-regex101.com" class="nav-link" data-scroll-target="#regex101.com">Regex101.com</a></li>
  <li><a href="#splitting-socrata-addresses" id="toc-splitting-socrata-addresses" class="nav-link" data-scroll-target="#splitting-socrata-addresses">Splitting Socrata addresses</a>
  <ul class="collapse">
  <li><a href="#the-goal-in-a-nutshell" id="toc-the-goal-in-a-nutshell" class="nav-link" data-scroll-target="#the-goal-in-a-nutshell">The goal in a nutshell</a></li>
  <li><a href="#capturing-the-address" id="toc-capturing-the-address" class="nav-link" data-scroll-target="#capturing-the-address">Capturing the address</a></li>
  </ul></li>
  <li><a href="#capturing-the-city" id="toc-capturing-the-city" class="nav-link" data-scroll-target="#capturing-the-city">Capturing the city</a></li>
  <li><a href="#capturing-the-state" id="toc-capturing-the-state" class="nav-link" data-scroll-target="#capturing-the-state">Capturing the state</a>
  <ul class="collapse">
  <li><a href="#catching-errors" id="toc-catching-errors" class="nav-link" data-scroll-target="#catching-errors">Catching errors</a></li>
  <li><a href="#back-to-the-state" id="toc-back-to-the-state" class="nav-link" data-scroll-target="#back-to-the-state">Back to the state</a></li>
  </ul></li>
  <li><a href="#capturing-the-zip" id="toc-capturing-the-zip" class="nav-link" data-scroll-target="#capturing-the-zip">Capturing the ZIP</a></li>
  <li><a href="#capturing-latitude" id="toc-capturing-latitude" class="nav-link" data-scroll-target="#capturing-latitude">Capturing latitude</a></li>
  <li><a href="#capturing-longitude" id="toc-capturing-longitude" class="nav-link" data-scroll-target="#capturing-longitude">Capturing longitude</a></li>
  <li><a href="#the-substitution-string" id="toc-the-substitution-string" class="nav-link" data-scroll-target="#the-substitution-string">The substitution string</a></li>
  <li><a href="#limitations-of-regex101" id="toc-limitations-of-regex101" class="nav-link" data-scroll-target="#limitations-of-regex101">Limitations of regex101</a></li>
  <li><a href="#using-a-code-editor" id="toc-using-a-code-editor" class="nav-link" data-scroll-target="#using-a-code-editor">Using a code editor</a></li>
  <li><a href="#more-regex" id="toc-more-regex" class="nav-link" data-scroll-target="#more-regex">More Regex</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Wrangling data with Regular Expressions</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Christian McDonald </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 14, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-note callout-titled" title="An oft-quoted saying">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
An oft-quoted saying
</div>
</div>
<div class="callout-body-container callout-body">
<p>Some people, when confronted with a problem, think …</p>
<p>“I know, I’ll use regular expressions.”</p>
<p>Now they have two problems.</p>
<p>– Discussion about the <a href="https://regex.info/blog/2006-09-15/247">source of the quote</a>.</p>
</div>
</div>
<section id="dont-fear-the-regex" class="level2">
<h2 class="anchored" data-anchor-id="dont-fear-the-regex">Don’t fear the regex</h2>
<p>A regular expression (regex or regexp for short) is a special text string for describing a search pattern. Searching text with a pattern instead for a specific string of characters can be VERY useful for cleaning data. The concept is available in many programming languages and tools.</p>
<p>This lesson explains what regular expressions are, how they can be useful in your everyday life as a journalist, and reveals ONE SIMPLE CONCEPT that can change your life.</p>
<p>While we’ll use <a href="https://regex101.com/">regex101.com</a> to learn the syntax, that site can handle only so much data. In practice, I tend to use regex101 to test my patterns on sample data, but then execute them in a spreadsheet formula, code editor or in a programming language like R or Python.</p>
<p>Links you will need in a browser:</p>
<ul>
<li>bit.ly/nicar-regex (this document)</li>
<li><a href="https://regex101.com/">regex101.com</a></li>
<li><a href="https://raw.githubusercontent.com/utdata/regex-lesson/main/socrata_addresses.txt">bit.ly/nicar-regex-sample</a></li>
<li><a href="https://docs.google.com/document/d/0B8ConnGcXrv8MzE3SWtwU2NxQk0/edit?resourcekey=0-DhAumbANwf8d0AGz9dpWhQ">bit.ly/nicar-regex-cheats</a></li>
</ul>
<p>NOTE: When you use the bit.ly links above you may get an advertising page before you get to the target page. You can just click <strong>Continue to destination</strong> to get past it.</p>
<p>Key concept: patterns Let’s say you have a list of phone numbers in 10-digit format – <code>512-555-1212</code> – but you want the area code to be in parenthesis: <code>(512) 555-1212</code>. You could do a simple search of the 512 area code followed by a dash <code>512-</code> and replace it with an area code in parenthesis and a space: <code>(512)</code>.</p>
<p>But what if there are different area codes in the list?</p>
<pre><code>512-555-1211
301-333-1212
404-123-1213</code></pre>
<p>With regular expressions, you can search for a pattern of characters. Instead of searching just for <code>512-</code>, you can look for “three numbers together at the beginning of a line that are then followed by a dash”.</p>
<p>If you capture that matching pattern as a group, you can then replace that group with parenthesis outside it, no matter what the contents of the group. If that saved group is called <code>$1</code> then you can replace it with <code>($1)</code> and it doesn’t matter if <code>$1</code> is equal to <code>512-</code> or <code>301-</code>.</p>
</section>
<section id="special-characters-commands-and-escape" class="level2">
<h2 class="anchored" data-anchor-id="special-characters-commands-and-escape">Special characters, commands and escape</h2>
<p>Let’s touch quickly on the syntax of regular expressions. Don’t get hung up if these sound like gibberish, because it will make more sense when we start using it. Your <a href="https://drive.google.com/file/d/0B8ConnGcXrv8MzE3SWtwU2NxQk0/view?usp=sharing">Regex Cheat Sheet</a> (or <a href="https://drive.google.com/open?id=0B8ConnGcXrv8bnJwdEtWVGx4N0E">this alternative</a>) comes in handy here.</p>
<p>Regular expressions use special characters to do special things, like match the beginning of a line. These commands are called tokens:</p>
<ul>
<li><code>^</code> will find the beginning of a line.</li>
<li><code>*</code> will find “zero or more” of whatever precedes it.</li>
</ul>
<p>Regular expressions use the backslash (the one above return on the keyboard: <code>\</code>) with other characters to create more tokens to do special things:</p>
<ul>
<li><code>\d</code> will find any number character (or digit).</li>
<li><code>\D</code> will match anything other than a number.</li>
<li><code>\t</code> is a tab character, because hitting the tab on the keyboard will perform the action instead of giving you the character.</li>
</ul>
<p>But then sometimes, you actually need to find the character ^, and not use it as a command. Regular expressions use the &nbsp;to give the literal expression of a character that would otherwise be a token:</p>
<ul>
<li><code>\*</code> will find the asterisk character instead of modifying the query to find “zero or more”.</li>
</ul>
<p>Enough of that. Let’s do this, with the help of …</p>
</section>
<section id="regex101.com" class="level2">
<h2 class="anchored" data-anchor-id="regex101.com">Regex101.com</h2>
<p><a href="https://regex101.com/">Regex101</a> is a great way to not only build regex patterns, but to also learn how they work. Go ahead and launch that site in a browser so we can work with it here in a minute.</p>
<p>We’re going to use this tool to split complicated address data into individual parts. Let’s talk about the data first.</p>
</section>
<section id="splitting-socrata-addresses" class="level2">
<h2 class="anchored" data-anchor-id="splitting-socrata-addresses">Splitting Socrata addresses</h2>
<p>Many government agencies use software run by Tyler Technologies as their open data portal: From <a href="https://data.austintexas.gov/">Austin</a> to <a href="https://data.cityofboston.gov/">Boston</a>; from <a href="https://data.lacity.org/browse">Los Angeles</a> to <a href="https://data.cityofnewyork.us/browse">New York</a>. The platform was once called Socrata.</p>
<p>Some of the data sets in Austin have all the address parts crammed into a single field. Regex can easily explode that into individual columns.</p>
<p>So, our goal is to turn this:</p>
<p><img src="images/regex101/image13.png" class="img-fluid"></p>
<p>into this:</p>
<p><img src="images/regex101/image1.png" class="img-fluid"></p>
<section id="the-goal-in-a-nutshell" class="level3">
<h3 class="anchored" data-anchor-id="the-goal-in-a-nutshell">The goal in a nutshell</h3>
<p>We are building a pattern in our regular expression field, creating a group to capture each part of the address that we want to keep. We’ll continue the pattern outside the group until we get to the next part we want to keep, when we’ll create a new group, and so on.</p>
<p>You’ll want to reference your <a href="https://drive.google.com/file/d/0B8ConnGcXrv8MzE3SWtwU2NxQk0/view?usp=sharing">Regex Cheat Sheet</a> (or <a href="https://drive.google.com/open?id=0B8ConnGcXrv8bnJwdEtWVGx4N0E">this alternative</a>.</p>
<p>Let’s get started:</p>
<ol type="1">
<li><p>Go to this link <a href="https://raw.githubusercontent.com/utdata/regex-lesson/master/socrata_addresses.txt">socrata_addresses.txt</a> will just open in a browser. Copy the contents of that screen.</p>
<ul>
<li>Some browsers might download the files instead of viewing. If so, go to <a href="https://github.com/utdata/regex-lesson/blob/main/data/socrata_addresses_long.txt">this page</a> and use the copy button in the tools there to get the content.</li>
</ul></li>
<li><p>If not there already, go to <a href="https://regex101.com/">regex101.com</a> and then paste that text into the “TEST STRING” field.</p>
<p>Note this is just one column from a larger Socrata data set of restaurant inspection scores in Austin, TX. (Sometimes when I want to clean a single column of data, I’ll just copy out one column into my text editor and work it before pasting back the results into Excel, carefully making sure they still line up.)</p>
<p>Let’s look at our data a little closer. This is really two rows of data, even though there are six lines of text here:</p>
<p><img src="images/regex101/image3.png" class="img-fluid"></p>
<p>Notice the address, city, state, zip, latitude and longitude are all in the same “cell” (what is inside the quote marks), but the content of the cell has returns in it. We want to split these six distinct pieces into their own columns for each record. Why? Many reasons, but one is to use the latitude and longitude for data visualizations.</p>
<p>We will build a Regular Expression pattern to search and capture six groups of text and then replace those groups with tabs between them so we can put them back into Excel as columns.</p></li>
<li><p>In regex101, in the right-hand box of the REGULAR EXPRESSION string, make sure there is a green <strong>/gm</strong> listed. If not, click on the <strong>/</strong> and choose the first two options “global” and “multiline”. <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p></li>
</ol>
</section>
<section id="capturing-the-address" class="level3">
<h3 class="anchored" data-anchor-id="capturing-the-address">Capturing the address</h3>
<p>For the next while, we’ll be building our expression in the REGULAR EXPRESSION field in regex101. So when I say add or edit the expression, that’s where we are doing it.</p>
<ol type="1">
<li><p>We know that the first line starts at the beginning of the line, so we can start with this token, which signifies that: <code>^</code></p></li>
<li><p>Now, in the end, we don’t want to keep the double-quote, so we won’t put it inside a group. We’ll just add it to the pattern: <code>^"</code></p>
<p>This is what it looks like:</p>
<p><img src="images/regex101/image16.png" class="img-fluid"></p>
<p>Take note of the number of matches at the top right: There are 325 matches, and that is how many records we should end up with. You’ll want to keep referring back to that and making sure you have 325 groups.</p></li>
<li><p>Next, we’ll start our first capture group by adding parenthesis: <code>^"()</code>. You’ll see as you type in the first parentheses, regex101 <em>might</em> also put in the second and then put your cursor in the middle of them. This is “code completion”, and good code editors do this to help you be more efficient. (If not, no big deal … just add it. It’s a setting you can adjust later.)</p></li>
<li><p>Inside the parenthesis (our first group), we want to capture the whole address, which is everything until the end of the line. The period token <code>.</code> means “any character”, and <code>*</code> means “zero or more”, so put these together and we get everything: <code>^"(.*)</code>.</p>
<p>Let’s take a minute to explain more about Regex101 and how it helps you.</p>
<p><img src="images/regex101/image15.png" class="img-fluid"></p>
<p>Each matching group gets a color, and the contents of the match is shown in MATCH INFORMATION. The EXPLANATION section tells you exactly how each token is used, and the QUICK REFERENCE section is a list of tokens you can use, more in depth than the cheat sheet I’ve started you with.</p>
<p>OK .. on with it.</p></li>
<li><p>Before we can start capturing the second group with the city, we need to add a return to the pattern (we’ll use the token <code>\n</code>) so it can start recognizing the next line. So add that at the end: <code>^"(.*)\n</code>.</p></li>
</ol>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p>Windows and MacOS treat new line tokens differently. On a Mac, <code>\n</code> is a “new line”, but Windows uses <code>\R</code>. The regex101 editor will recognize either, but later I’ll demonstrate doing a search and replace in a code editor, and if you are following along you must use the character that works with your operating system. This tutorial is written from a Mac perspective, so I use <code>\n</code>. If you are on a PC, you might use <code>\R</code> every time you see <code>\n</code> in this tutorial.</p>
</div>
</div>
<p><strong>Sanity check:</strong> This what your screen should look like:</p>
<p><img src="images/regex101/image9.png" class="img-fluid"></p>
</section>
</section>
<section id="capturing-the-city" class="level2">
<h2 class="anchored" data-anchor-id="capturing-the-city">Capturing the city</h2>
<p>Now, let’s grab the city. As we look through the list, we can see there is more than Austin, and some of these names have spaces so we can’t find just letters alone.</p>
<ol type="1">
<li>There are MANY ways to do this, but we’ll do it here by creating a group first: <code>^"(.*)\n()</code>.</li>
<li>Then inside the group we’ll put a token that looks for word characters: <code>^"(.*)\n(\w)</code>.</li>
<li>Then we’ll add the quantifier + to find “one or more” of what’s in the character set: <code>^"(.*)\n(\w+)</code>.</li>
</ol>
<p>Make sure we are capturing all 325 groups. We should be good.</p>
</section>
<section id="capturing-the-state" class="level2">
<h2 class="anchored" data-anchor-id="capturing-the-state">Capturing the state</h2>
<p>These are all the same in this data, all in TX, so we don’t really have to save it at all, but we will. We’ll use this to remind ourselves that you can also just match a string literally.</p>
<ol type="1">
<li>First we put the comma and space outside the second group, since we don’t want to keep it: <code>^"(.*)\n(\w+),</code>.</li>
</ol>
<section id="catching-errors" class="level3">
<h3 class="anchored" data-anchor-id="catching-errors">Catching errors</h3>
<p>Now, take a moment and check how many matching groups we have. Wait … WHOA … we have only 314. What could’ve gone wrong?</p>
<ol type="1">
<li>Scroll down the Test string until you find something amiss. The colors help you spot problems easily.</li>
</ol>
<p><img src="images/regex101/image14.png" class="img-fluid"></p>
<p>What is the difference between the working lines and the ones that aren’t? Something about the city.</p>
<p>BEE CAVE and WEST LAKE HILLS have spaces while AUSTIN and PFLUGERVILLE do not. It looks like our city group did not capture a needed space, which wasn’t really revealed until we tried to carry out the pattern with the , that is found after the city. This happens a lot … we need to back up and fix the error.</p>
<p>Right now, our expression is this: <code>^"(.*)\n(\w+),</code> and the part that captures the city is <code>(\w+)</code>. We need to use something called a “character set” that allows us to include more than one token within a group. We signify this by putting what we want inside of square brackets: So we need to put the <code>\w</code> inside square brackets along with the space so we can catch both: <code>^"(.*)\n([\w ]+),</code>.</p>
</section>
<section id="back-to-the-state" class="level3">
<h3 class="anchored" data-anchor-id="back-to-the-state">Back to the state</h3>
<ol type="1">
<li>Then we create our third group with TX inside it: <code>^"(.*)\n([\w ]+), (TX)</code>. We are looking for the literal text TX because there are no other states in this data set. We can’t skip it because we need the pattern to continue.</li>
</ol>
<p><strong>Sanity check.</strong> Here is what you should have:</p>
<p><img src="images/regex101/image10.png" class="img-fluid"></p>
</section>
</section>
<section id="capturing-the-zip" class="level2">
<h2 class="anchored" data-anchor-id="capturing-the-zip">Capturing the ZIP</h2>
<ol type="1">
<li>Again, we don’t want to keep the space between the state and ZIP, so we’ll put it outside the third group, and start our fourth one for ZIP: <code>^"(.*)\n([\w ]+), (TX) ()</code>.</li>
<li>All of these zip codes are of the 5-digit variety, so this can be less complicated than it might be with 9-digit ZIPs. Again, there are many ways to do this, but we’ll use <code>\d</code> for the numbers and <code>*</code> to capture zero or more of them: <code>^"(.*)\n([\w ]+), (TX) (\d*)</code>.</li>
<li>Complete the pattern for this line with the new line token: <code>^"(.*)\n([\w ]+), (TX) (\d*)\n</code>.</li>
</ol>
<p><strong>Sanity check.</strong> This is where we are:</p>
<p><img src="images/regex101/image11.png" class="img-fluid"></p>
</section>
<section id="capturing-latitude" class="level2">
<h2 class="anchored" data-anchor-id="capturing-latitude">Capturing latitude</h2>
<ol type="1">
<li>We don’t want to keep the parenthesis that starts this last line, so we’ll put it outside a group. However, since parenthesis mean something special in regex, we need to escape it with a backslash so it will find the character and not start the new group: <code>^"(.*)\n([\w ]+), (TX) (\d*)\n\(</code>. Code completion might make this tricky, but you can do it!</li>
</ol>
<ul>
<li>Now we can start our new group, so go ahead and add the beginning and end parentheses: <code>^"(.*)\n([\w ]+), (TX) (\d*)\n\(()</code>.</li>
<li>Inside our fifth group, we need numbers and the decimal point. We will create a character set using square brackets and put inside it <code>\d</code> for numbers and <code>\.</code> for the decimal point, which we have to escape since . means “any character”. We finish it off by using + to look for one or more of the characters in the set. Like this: <code>^"(.*)\n([\w ]+), (TX) (\d*)\n\(([\d\.]+)</code>.</li>
</ul>
</section>
<section id="capturing-longitude" class="level2">
<h2 class="anchored" data-anchor-id="capturing-longitude">Capturing longitude</h2>
<ul>
<li>We don’t need the comma and space in our next group, so we put it outside to keep the pattern going: <code>^"(.*)\n([\w ]+), (TX) (\d*)\n\(([\d\.]+),</code>.</li>
<li>We can get the longitude like we did latitude, but we have to add the hyphen to the character set. So, create the group: <code>^"(.*)\n([\w ]+), (TX) (\d*)\n\(([\d\.]+), ()</code>.</li>
<li>Add the character set: <code>^"(.*)\n([\w ]+), (TX) (\d*)\n\(([\d\.]+), ([])</code>.</li>
<li>And inside of it, put <code>\d</code> for digits, <code>\-</code> for the hyphen and <code>\.</code> for the decimal point: <code>^"(.*)\n([\w ]+), (TX) (\d*)\n\(([\d\.]+), ([\d\-\.])</code>. Add our quantifier to get one or more: <code>^"(.*)\n([\w ]+), (TX) (\d*)\n\(([\d\.]+), ([\d\-\.]+)</code>. Because the trailing parentheses and quote are at the end of a line, we could ignore them, but we won’t. We’ll add them to the end of the pattern, escaping the close parentheses just to be sure: <code>^"(.*)\n([\w ]+), (TX) (\d*)\n\(([\d\.]+), ([\d\-\.]+)\)"</code>.</li>
</ul>
<p><img src="images/regex101/image7.png" class="img-fluid"></p>
<p>You have it all! 325 matches into 6 different groups.</p>
</section>
<section id="the-substitution-string" class="level2">
<h2 class="anchored" data-anchor-id="the-substitution-string">The substitution string</h2>
<p>Now that we have a pattern with our six groups of data, we can substitute them in any order we want using a search and replace, and we can build our substitution string right here in Regex101 as well.</p>
<p>In the left-hand navigation under the FUNCTION heading, click on the item called Substitution. That should expand the SUBSTITUTION window.</p>
<p><img src="images/regex101/image2.png" class="img-fluid"></p>
<p>Now we can build a substitution string, and we can see the cleaned data in the window below.</p>
<p>Our goal with the substitution string is to pull back our six groups, but to put tabs in between each of them. If we can build a search and replace like this, then we can paste the result back into Excel, and each group will become its own column.</p>
<p>A quick refresher from our intro: Once we’ve built a group, we can reference it in our substitution string by order in which we captured it. So, if we want to reference our first group, we use this: <code>$1</code>.</p>
<ol type="1">
<li><p>Put that in the SUBSTITUTION string box, like this:</p>
<p><img src="images/regex101/image12.png" class="img-fluid"></p>
<p>You can see that Regex101 is now pulling back our address.</p>
<p>We can’t just type a tab key after our group because they keyboard command will move us to another box, so we use the token for tab, which is <code>\t</code>.</p></li>
<li><p>So, add that to the end of our substitution string to get this: <code>$1\t</code>. You’ll see space get added into our substitution example.</p></li>
<li><p>Now we can add our next ordered group to our substitution string and see our city get added on<code>: $1\t$2</code>.</p>
<p>Here is a <strong>sanity check</strong>:</p>
<p><img src="images/regex101/image8.png" class="img-fluid"></p></li>
<li><p>Now that you see how it works, let’s go ahead and add the rest of the groups, all with tabs in between them: <code>$1\t$2\t$3\t$4\t$5\t$6</code>. Your screen might look a little different than below if the lines start wrapping.</p></li>
</ol>
<p><img src="images/regex101/image6.png" class="img-fluid"></p>
<p>Now, you might try copy ‘n’ pasting this result into Excel or Google Sheets and it will become six distinct columns.</p>
</section>
<section id="limitations-of-regex101" class="level2">
<h2 class="anchored" data-anchor-id="limitations-of-regex101">Limitations of regex101</h2>
<p>This can work fine for a small data set, but things bog down on the site if you have many rows or columns of data. I often use regex101 with sample text to figure out my patterns, but then use them in a text editor or within a R or Python script. You can see how to use regex in Find/Replace for various text editors below.</p>
<p>You can actually save this example in regex101 under SAVE &amp; SHARE in the top left panel. If you create a login with regex101 you can keep a dashboard of them.</p>
<p>My example is saved here: <a href="https://regex101.com/r/dVFG6T/2/" class="uri">https://regex101.com/r/dVFG6T/2/</a></p>
<blockquote class="blockquote">
<p>Reporting with Data students can stop here and save your regex101 link and submit it in Canvas. I’ll demo the rest in class.</p>
</blockquote>
</section>
<section id="using-a-code-editor" class="level2">
<h2 class="anchored" data-anchor-id="using-a-code-editor">Using a code editor</h2>
<p>We are almost done. Go ahead and launch your text editor if you haven’t already. I’ll show this in Visual Studio Code.</p>
<ol type="1">
<li><p>Take your TEST STRING data (not the expression, but the data) and paste it into a new next file in your text editor. (Or grab it from the file you downloaded.)</p></li>
<li><p>Go under the <em>Edit</em> menu to <em>Replace</em> (or do control-H for PC, command-option-F for Mac) to bring up the search window.</p></li>
<li><p>Copy the Regular Expression pattern you built in Regex101 and insert into the <em>Find</em> text field in VS Code.</p></li>
<li><p>Copy the Substitution pattern and insert it into the <em>Replace</em> field.</p></li>
<li><p>Click on the button on the far-right of the Find line, the one that has <code>.*</code> in it.</p>
<p>Here is what the search and replace screen looks like in VS Code:</p>
<p><img src="images/regex101/image5.png" class="img-fluid"></p></li>
<li><p>Now, hit the “Replace All” button to the far-right of the Replace field and watch the magic happen.</p></li>
</ol>
<p>Once you run the search and replace, you can copy and paste the results into a spreadsheet and it will be six distinct columns. (If it doesn’t, hollar.)</p>
</section>
<section id="more-regex" class="level2">
<h2 class="anchored" data-anchor-id="more-regex">More Regex</h2>
<p>There are lots of sites and tutorials on regular expressions, but <a href="http://www.regular-expressions.info/" class="uri">http://www.regular-expressions.info/</a> is one of my favorites.</p>
<p>And remember, if you are stumped by something, chances are you are not the first. Google and Stack Overflow are your friends. ChatGPT might be helpful, too, if you are good at prompts.</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>On the modifier “gm”: The “g” is for “global”, as in find all occurrences, not just the first one. The “m” is for “multi-line”, which allows us to evaluate each line separately. I almost always use “gm” when doing search and replace like this.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>