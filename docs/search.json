[
  {
    "objectID": "cheatsheet.html",
    "href": "cheatsheet.html",
    "title": "Cheatsheet",
    "section": "",
    "text": "Token\nUse\n\n\n\n\n[abc]\nA single character of: a, b, or c\n\n\n[^abc]\nAny single character except: a, b, or c\n\n\n[a-z]\nAny single character in the range a-z\n\n\n[a-zA-Z]\nAny single char in the range a-z or A-Z\n\n\n(…)\nCapture everything enclosed\n\n\n(a|b)\na or b\n\n\na?\nZero or one of a (lazy)\n\n\na*\nZero or more of a (greedy)\n\n\na+\nOne or more of a\n\n\na{3}\nExactly 3 of a\n\n\na{3,}\n3 or more of a\n\n\na{3,6}\nBetween 3 and 6 of a\n\n\n^\nStart of line\n\n\n$\nEnd of line\n\n\n\\A\nStart of string\n\n\n\\z\nEnd of string\n\n\n.\nAny single character\n\n\n\\s\nAny whitespace character\n\n\n\\S\nAny non-whitespace character\n\n\n\\d\nAny digit\n\n\n\\D\nAny non-digit\n\n\n\\w\nAny word character (letter, number, underscore)\n\n\n\\W\nAny non-word character\n\n\n\\b\nAny word boundary"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Wrangling Regular Expressions",
    "section": "",
    "text": "Important\n\n\n\nThis is a backup lesson in case the internet is not available. It’s designed to present from the downloaded repo using Visual Studio code. It is not as cool as https://regex101.com, but it will do.\nA regular expression (regex or regexp for short) is a special text string for describing a search pattern. Searching text with a pattern instead for a specific string of characters can be VERY useful for cleaning data. The concept is available in many programming languages and tools."
  },
  {
    "objectID": "index.html#key-concept-patterns",
    "href": "index.html#key-concept-patterns",
    "title": "Wrangling Regular Expressions",
    "section": "Key concept: patterns",
    "text": "Key concept: patterns\nLet’s say you have a list of phone numbers in 10-digit format – 512-555-1212 – but you want the area code to be in parentheses: (512) 555-1212. You could do a simple search of the “512” area code followed by a dash “512-” and replace it with an area code in parentheses and a space: “(512)”.\nBut what if there are different area codes in the list?\n512-555-1211\n301-333-1212\n410-123-1213\nWith regular expressions, you can search for a pattern of characters. Instead of searching just for 512-, you can look for “three numbers together at the beginning of a line that are then followed by a dash”.\nIf you capture that matching pattern as a group, you can then replace that group with parentheses outside it, no matter what the contents of the group. If that saved group is called $1 then you can replace it with ($1) and it doesn’t matter if $1 is equal to “512-” or “301-”."
  },
  {
    "objectID": "index.html#special-characters-commands-and-escape",
    "href": "index.html#special-characters-commands-and-escape",
    "title": "Wrangling Regular Expressions",
    "section": "Special characters, commands and escape",
    "text": "Special characters, commands and escape\nLet’s touch quickly on the syntax of regular expressions. Don’t get hung up if these sound like gibberish, because it will make sense more when we start using it. This Cheatsheet comes in handy here.\nRegular expressions use special characters to do special things, like match the beginning of a line. These commands are called tokens. Some examples:\n^ will find the beginning of a line\n* will find “zero or more” of whatever precedes it.\nRegular expressions use the backslash (the one above return on a keyboard where the top tips to the left) with other characters to create more tokens to do special things:\n\\d will find any number character (or digit).\n\\D will match anything other than a number.\n\\t is a tab character, because hitting the tab on the keyboard will perform the action instead of giving you the character.\nBut then sometimes, you actually need to find the character ^, and not use it as a command. Regular expressions use the  to give the literal expression of a character that would otherwise be a token:\n\\* will find the asterisk character instead of the token to find “zero or more”."
  },
  {
    "objectID": "index.html#defining-our-goal",
    "href": "index.html#defining-our-goal",
    "title": "Wrangling Regular Expressions",
    "section": "Defining our goal",
    "text": "Defining our goal\nWe’re going to use regular expressions to split complicated address data into individual parts. The sample we’ll use is a column from some City of Austin data published on their Socrata open data portal.\nIt had all the address parts crammed into a single field. Regex can easily explode that into individual columns, which is more useful to us.\nSo, our goal is to turn this …\n\"10111 N LAMAR BLVD\nAUSTIN, TX 78753\n(30.370945933000485, -97.6925542359997)\"\n\"2620 LAKE AUSTIN BLVD\nAUSTIN, TX 78703\n(30.28190796500047, -97.77587573499966)\"\n… into this, with each address part separated with a tab:\n10111 N LAMAR BLVD  AUSTIN  TX  78753    30.370945933000485  -97.6925542359997\n2620 LAKE AUSTIN BLVD   AUSTIN  TX  78703   30.28190796500047   -97.77587573499966\nWith this change, we can copy/paste the results into a spreadsheet."
  },
  {
    "objectID": "index.html#the-goal-in-a-nutshell",
    "href": "index.html#the-goal-in-a-nutshell",
    "title": "Wrangling Regular Expressions",
    "section": "The goal in a nutshell",
    "text": "The goal in a nutshell\nWe are building a pattern in our regular expression field, creating “capture groups” for each part of the address that we want to keep. We’ll continue the pattern outside the group until we get to the next part we want to keep, when we’ll create a new group, and so on.\nYou’ll want to reference your Regex-Cheatsheet.docx or Regular-expressions-syntax.pdf in the resources folder.\nLet’s get started:\n\nFrom Visual Studio Code where you are working with this, click on the file data/socrata_addresses_copy.txt to open it.\n\nNote this is just one column from a larger Socrata data set of restaurant inspection scores in Austin, TX. (When I want to clean a single column of data, I often download the data and will just copy out one column into my text editor and work it before pasting back the results into a new Excel column, carefully making sure they still line up.)\nLet’s look at our data a little closer. This example from the top of the file is just one “cell” of data, even though it has multiple lines of text\n\"10111 N LAMAR BLVD\nAUSTIN, TX 78753\n(30.370945933000485, -97.6925542359997)\"\nThe address, city, state, zip, latitude and longitude are all in the same “cell” (what is inside the quote marks), but the content of the cell has returns in it. We want to split these six distinct pieces into their own columns for each record. Why? Many reasons, but one is to use the latitude and longitude for data visualizations.\nWe will build a Regular Expression pattern to Find and capture six groups of text and then Replace those groups with tabs between them so we can put them back into a spreadsheet as columns."
  },
  {
    "objectID": "index.html#building-our-find-pattern",
    "href": "index.html#building-our-find-pattern",
    "title": "Wrangling Regular Expressions",
    "section": "Building our Find pattern",
    "text": "Building our Find pattern\n\nIn your data/socrata_addresses_copy.txt file, do Command-option-f to open the Find and Replace box. (Or menu: Edit &gt; Replace)\nThe Find/Replace window will open at the top right.\nNext to Find you’ll find some options. Click on the one that is a period-asterisk: .*\n\n\n\nFind and Replace prompt\n\n\n\n\nCapturing the address\nWe’ll begin entering tokens into the “Find” prompt so we can see how to use tokens to capture patterns. In some cases, we’ll “capture” the pattern using parentheses, so we can refer back to it later.\nWe know that the first line starts at the beginning of the line, so we can start with this token: ^.\n\nAdd the ^ to the Find prompt.\nYou’ll see that the first character of each line is now highlighted.\nNext we want to add the double-quote so we can continue the pattern from the beginning of each address. Add a double-quote after the first token, like this:\n^\"\nYou’ll notice that now only the double-quote marks are selected.\n\n\n\nFirst quote selected\n\n\nNext, we’ll start our first capture group with parentheses:\n^\"()\nYou’ll see as you type in the open parentheses that you’ll get an “error” in the Find box because it expects a closing parentheses. Make sure you add that, then put your cursor back between them.\nNow, inside those parentheses, we’ll add .* so the full line looks like this:\n^\"(.*)\nYou’ll see that the rest of the line has been selected.\nInside the parentheses (our first group), we want to capture the whole address, which is everything until the end of the line. The period token . means “any character”, and * means “zero or more”, so put these together and we get everything: ^\"(.*).\n\n\n\nAddress line\n\n\n\n\n\n\n\n\n\nNew lines differe between Mac and PCs\n\n\n\nBefore we can start capturing the second group with the city, we need to add the “return” to the pattern so it can start recognizing the next line. But here’s the drive-you-crazy thing: Windows and Macs treat these differently. On a Mac, \\n is a “new line”. If you are on a Windows machine, you’ll need to use \\R. My screenshots use a Mac, so if we end up with PC’s in this lab, you’ll need to use \\R every time you see \\n in this tutorial.\n\n\n\nAdd \\n to the end of the string to make:\n^\"(.*)\\n\n\n\n\nAddress line with return\n\n\n\n\n\nCapturing the city\nAs we look through the list, you can see we have some cities with more than one word – like “BEE CAVE” – so we need a way to capture both letters and spaces, but not other punctuation. There are MANY ways to do this, but we’ll use a “character set” to show how to use more than one token at a time:\n\nFirst, create a new group:\n^\"(.*)\\n()\nThen inside the group, we have to build the “character set” using square brackets. Inside those brackets we’ll ad a \\w token to catch any word character, and a space so we can catch those, too. Lastly, we put a + token right after the character set to signify we want “one or more”:\n^\"(.*)\\n([\\w ]+)\n\n\n\nCity captured\n\n\n\n\n\nCapturing the state\nThese addresses are all in TX, so we don’t really have to save it at all, but we will. We’ll use this to remind ourselves that you can also just match a string literally.\n\nFirst we put the comma and space outside the second group, since we don’t want to keep it:\n^\"(.*)\\n(\\w+),\n\n\n\nCity with comma and space\n\n\nYou can’t see that trailing space in the image above, but make sure it is there.\nThen we create our third group with TX inside it:\n^\"(.*)\\n([\\w ]+), (TX)\n\n\n\nAdding TX\n\n\n\nWe choose to find the literal text “TX” because there are no other states in this data set. We can’t skip it because we need the pattern to continue.\n\n\nCapturing the ZIP\nAgain, we don’t want to keep the space between the state and ZIP, so we’ll put it outside the third group.\n\nAdd the comma, space and new group to start our fourth group:\n^\"(.*)\\n([\\w ]+), (TX) ()\nAll of these zip codes are of the 5-digit variety, so this can be less complicated than it might be with 9-digit ZIPs. Again, there are many ways to do this, but we’ll use \\d for the numbers and * to capture zero or more of them. Add those inside the capture group:\n^\"(.*)\\n([\\w ]+), (TX) (\\d*)\nComplete the pattern for this line with the new line token \\n. (NOTE: Remember to change the \\n to \\R if we are on PCs):\n^\"(.*)\\n([\\w ]+), (TX) (\\d*)\\n\n\n\n\nZip captured to end of line\n\n\n\n\n\nCapturing latitude\n\nWe don’t want to keep the parentheses that starts this last line, so we’ll put it outside any capture group. However, since parentheses mean something special in regex, we need to escape it with a backslash so it will find the character and not start the new group:\n^\"(.*)\\n([\\w ]+), (TX) (\\d*)\\n\\(\nNow we can start our new group, so go ahead and add the beginning and end parentheses:\n^\"(.*)\\n([\\w ]+), (TX) (\\d*)\\n\\(()\nInside our fifth group, we need numbers and the decimal point. We will create a character set using square brackets and put inside it \\d for numbers and \\. for the decimal point, which we have to escape since . means “any character”. We finish it off by using + to look for one or more of the characters in the set. Like this:\n^\"(.*)\\n([\\w ]+), (TX) (\\d*)\\n\\(([\\d\\.]+)\n\n\n\nLatitude captured\n\n\n\n\n\nCapturing longitude\n\nWe don’t need the comma and space in our next group, so we put it outside to keep the pattern going:\n^\"(.*)\\n([\\w ]+), (TX) (\\d*)\\n\\(([\\d\\.]+),\nWe can get the longitude like we did latitude, but we have to add the hyphen to the character set. So, create the group:\n^\"(.*)\\n([\\w ]+), (TX) (\\d*)\\n\\(([\\d\\.]+), ()\nAdd the character set:\n^\"(.*)\\n([\\w ]+), (TX) (\\d*)\\n\\(([\\d\\.]+), ([])\nAnd inside of it, put \\d for digits, \\- for the hyphen and \\. for the decimal point:\n^\"(.*)\\n([\\w ]+), (TX) (\\d*)\\n\\(([\\d\\.]+), ([\\d\\-\\.])\nAdd our quantifier to get one or more:\n^\"(.*)\\n([\\w ]+), (TX) (\\d*)\\n\\(([\\d\\.]+), ([\\d\\-\\.]+)\nBecause the trailing parentheses and quote are at the end of a line, we could ignore them, but we won’t. We’ll add them to the end of the pattern, escaping the close parentheses just to be sure:\n^\"(.*)\\n([\\w ]+), (TX) (\\d*)\\n\\(([\\d\\.]+), ([\\d\\-\\.]+)\\)\"\n\n\n\nLongitude captured"
  },
  {
    "objectID": "index.html#the-replace-string",
    "href": "index.html#the-replace-string",
    "title": "Wrangling Regular Expressions",
    "section": "The Replace string",
    "text": "The Replace string\nNow that we have a pattern with our six groups of data, we keep or exclude them in any order we want using the Replace prompt and the replace all icon.\nOur goal is to bring back six of our groups, but to put tabs in between each of them. If we can build a search and replace like this, then we can paste the result back into Excel, and each group will become its own column.\nA quick refresher from our intro: Once we’ve built a group, we can reference it in our substitution string by order in which we captured it. So, if we want to reference our first group, we use this: $1.\n\nAdd this to the Replace prompt:\n$1\nClick the second icon next to the replace string (which is replace all):\n\n\n\nThe replace all button\n\n\nNow that you’ve seen that, do Edit &gt; Undo to put our data back!\nI wasn’t trying to scare you there, but you needed to see how replacing with a capture group worked.\nUpdate the Replace string to add a tab token \\t between each group.\n$1\\t$2\\t$3\\t$4\\t$5\\t$6\nAnd then use the replace all icon to do the Find/Replace on all rows.\n\n\n\nWe did it!\n\n\n\n\nAdd to Excel or Google Sheets\nThe way this text is structured, you can copy it all and then paste it into an Excel or Google Sheets spreadsheet and you should get six distinct rows.\n\n\n\nSheets gif"
  },
  {
    "objectID": "index.html#more-regex",
    "href": "index.html#more-regex",
    "title": "Wrangling Regular Expressions",
    "section": "More Regex",
    "text": "More Regex\nThere are lots of sites and tutorials on regular expressions, but regular-expressions.info is one of my favorites.\nAnd remember, if you are stumped by something, chances are you are not the first. Google and Stack Overflow are your friends. ChatGPT might be helpful, too, if you are good at prompts."
  }
]